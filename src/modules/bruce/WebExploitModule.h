#pragma once

#include <AsyncTCP.h>
#include <ESPAsyncWebServer.h>
#include <M5Unified.h>
#include <SD.h>

#include <vector>

#include "config.h"
#include "modules/Module.h"

namespace bruce::modules {

class WebExploitModule : public Module {
   public:
    explicit WebExploitModule(AsyncWebServer& server) : server_(server) {}

    const char* Name() const override { return "Security Portal"; }

   protected:
    void Init() override {
        EnsureDisplay();
        sd_ready_ = PrepareSd();
        LoadConfig();

        if (!HasWiFi()) {
            RenderUnavailable("WiFi inactive");
            return;
        }

        EnsureRoutes();
        RenderHeader();
        ShowStatus("A:start B:stop C:log", TFT_GREEN);
        if (auto_start_) {
            portal_enabled_ = true;
            Render();
        } else {
            RenderDisabled();
        }
    }

    void Update() override {
        if (info_message_active_ && millis() > info_message_until_) {
            info_message_active_ = false;
            Render();
        }

        if (DebouncedPress(M5.BtnA, last_press_a_)) {
            portal_enabled_ = true;
            ShowStatus("Portal online", TFT_GREEN);
            Render();
        }

        if (DebouncedPress(M5.BtnB, last_press_b_)) {
            portal_enabled_ = false;
            ShowStatus("Portal offline", TFT_YELLOW);
            RenderDisabled();
        }

        if (DebouncedPress(M5.BtnC, last_press_c_)) {
            if (sd_ready_ || PrepareSd()) {
                SavePortalLog();
            } else {
                ShowStatus("SD missing", TFT_RED);
            }
        }

        if (portal_enabled_ && millis() - last_render_ms_ > 1500) {
            Render();
        }
    }

    void Cleanup() override {
        portal_enabled_ = false;
        if (sd_ready_) {
            SaveConfig();
            SD.end();
            sd_ready_ = false;
        }
        captures_.clear();
        if (HasDisplay()) {
            M5.Display.clear();
        }
    }

   private:
    struct CredentialEntry {
        String user;
        String password;
        String note;
    };

    void EnsureDisplay() {
        if (HasDisplay()) {
            M5.Display.clear();
            M5.Display.setTextColor(TFT_WHITE, TFT_BLACK);
            M5.Display.setTextSize(1);
        }
    }

    bool PrepareSd() {
        if (sd_ready_) {
            return true;
        }
        if (SD.begin(kSdCsPin)) {
            if (!SD.exists("/config")) {
                SD.mkdir("/config");
            }
            if (!SD.exists("/logs")) {
                SD.mkdir("/logs");
            }
            sd_ready_ = true;
            return true;
        }
        return false;
    }

    void EnsureRoutes() {
        if (routes_registered_) {
            return;
        }
        server_.on("/", HTTP_GET, [this](AsyncWebServerRequest* request) { ServeLanding(*request); });
        server_.on("/portal", HTTP_GET, [this](AsyncWebServerRequest* request) { ServeLanding(*request); });
        server_.on("/capture", HTTP_GET, [this](AsyncWebServerRequest* request) { HandleCapture(*request); });
        server_.on("/status", HTTP_GET, [this](AsyncWebServerRequest* request) { ServeStatus(*request); });
        routes_registered_ = true;
    }

    void ServeLanding(AsyncWebServerRequest& request) {
        if (!portal_enabled_) {
            request.send(200, "text/html", "<h1>Training portal offline</h1>");
            return;
        }
        const char* page = R"HTML(
<!DOCTYPE html><html><head><meta charset='utf-8'><title>Security Training</title>
<style>body{font-family:sans-serif;background:#101820;color:#f2f2f2;padding:20px;}form{background:#1f2d3d;padding:20px;border-radius:8px;}label{display:block;margin:10px 0 4px;}input{width:100%;padding:8px;border-radius:4px;border:1px solid #3f4a5a;background:#0d141f;color:#fff;}button{margin-top:16px;padding:10px 20px;background:#3fa9f5;border:0;border-radius:4px;color:#101820;font-weight:bold;}footer{margin-top:24px;font-size:12px;color:#ccc;}</style>
</head><body>
<h1>Security Awareness Training Portal</h1>
<p>This captive portal simulation demonstrates how phishing sites collect credentials. Enter demo values to continue.</p>
<form action='/capture' method='GET'>
  <label for='user'>Username</label>
  <input id='user' name='user' placeholder='training@example.com' required>
  <label for='pass'>Password</label>
  <input id='pass' type='password' name='pass' placeholder='password123' required>
  <label for='note'>Training Notes</label>
  <input id='note' name='note' placeholder='Session observation'>
  <button type='submit'>Submit for Training</button>
</form>
<footer>For authorized security education only.</footer>
</body></html>
)HTML";
        request.send(200, "text/html", page);
    }

    void HandleCapture(AsyncWebServerRequest& request) {
        if (!portal_enabled_) {
            request.send(503, "text/plain", "portal disabled");
            return;
        }
        String user = request.hasParam("user") ? request.getParam("user")->value() : "";
        String pass = request.hasParam("pass") ? request.getParam("pass")->value() : "";
        String note = request.hasParam("note") ? request.getParam("note")->value() : "";
        CredentialEntry entry{user, pass, note};
        if (captures_.size() >= 8) {
            captures_.erase(captures_.begin());
        }
        captures_.push_back(entry);
        BRUCE_LOG_INFO(String("Portal capture from ") + user);
        Render();
        request.send(200, "text/html", "<h2>Captured for training. Please return to the device display.</h2>");
    }

    void ServeStatus(AsyncWebServerRequest& request) {
        String response = "{";
        response += "\"enabled\":";
        response += portal_enabled_ ? "true" : "false";
        response += ",\"captures\":";
        response += String(captures_.size());
        response += "}";
        request.send(200, "application/json", response);
    }

    void RenderHeader() {
        if (!HasDisplay()) {
            return;
        }
        M5.Display.clear();
        M5.Display.setCursor(0, 0);
        M5.Display.setTextColor(TFT_CYAN, TFT_BLACK);
        M5.Display.println("Security Portal");
        M5.Display.setTextColor(TFT_WHITE, TFT_BLACK);
    }

    void RenderDisabled() {
        if (!HasDisplay()) {
            return;
        }
        RenderHeader();
        M5.Display.println("Portal disabled.");
        M5.Display.println("Press A to enable.");
        M5.Display.println("C saves session log.");
        M5.Display.println("For training use only.");
    }

    void Render() {
        if (!HasDisplay()) {
            return;
        }
        if (!portal_enabled_) {
            RenderDisabled();
            return;
        }
        RenderHeader();
        M5.Display.println("Portal online");
        M5.Display.printf("Captures: %d\n", static_cast<int>(captures_.size()));
        size_t start = captures_.size() > 3 ? captures_.size() - 3 : 0;
        for (size_t i = start; i < captures_.size(); ++i) {
            const auto& entry = captures_[i];
            M5.Display.setTextColor(TFT_GREEN, TFT_BLACK);
            M5.Display.printf("%s\n", entry.user.c_str());
            M5.Display.setTextColor(TFT_YELLOW, TFT_BLACK);
            M5.Display.printf("  %s\n", entry.note.c_str());
            M5.Display.setTextColor(TFT_WHITE, TFT_BLACK);
        }
        M5.Display.println("------------------");
        M5.Display.println("A:Start B:Stop C:Save");
        last_render_ms_ = millis();
    }

    void ShowStatus(const String& message, uint16_t color) {
        BRUCE_LOG_INFO(String("Portal: ") + message);
        if (!HasDisplay()) {
            return;
        }
        info_message_active_ = true;
        info_message_until_ = millis() + 2000;
        M5.Display.setTextColor(color, TFT_BLACK);
        M5.Display.setCursor(0, 110);
        M5.Display.printf("%-20s\n", message.c_str());
        M5.Display.setTextColor(TFT_WHITE, TFT_BLACK);
    }

    void RenderUnavailable(const char* reason) {
        if (!HasDisplay()) {
            return;
        }
        RenderHeader();
        M5.Display.setTextColor(TFT_RED, TFT_BLACK);
        M5.Display.println(reason);
        M5.Display.setTextColor(TFT_WHITE, TFT_BLACK);
    }

    void SavePortalLog() {
        if (!sd_ready_) {
            return;
        }
        char timestamp[20];
        snprintf(timestamp, sizeof(timestamp), "%lu", millis());
        String path = String("/logs/portal_capture_") + timestamp + ".log";
        File file = SD.open(path, FILE_WRITE);
        if (!file) {
            ShowStatus("Log failed", TFT_RED);
            return;
        }
        file.println("user,password,note");
        for (const auto& entry : captures_) {
            file.print('"');
            file.print(entry.user);
            file.print('"');
            file.print(',');
            file.print('"');
            file.print(entry.password);
            file.print('"');
            file.print(',');
            file.print('"');
            file.print(entry.note);
            file.println('"');
            yield();
        }
        file.close();
        ShowStatus("Session saved", TFT_GREEN);
    }

    void LoadConfig() {
        auto_start_ = false;
        if (!sd_ready_ && !PrepareSd()) {
            return;
        }
        File file = SD.open("/config/web_portal.cfg", FILE_READ);
        if (!file) {
            return;
        }
        while (file.available()) {
            String line = file.readStringUntil('\n');
            line.trim();
            if (line.startsWith("auto_start=")) {
                auto_start_ = line.endsWith("1");
            }
        }
        file.close();
    }

    void SaveConfig() {
        File file = SD.open("/config/web_portal.cfg", FILE_WRITE);
        if (!file) {
            BRUCE_LOG_WARN("Failed to persist portal config");
            return;
        }
        file.print("auto_start=");
        file.println(auto_start_ ? "1" : "0");
        file.close();
    }

    AsyncWebServer& server_;
    bool routes_registered_ = false;
    bool portal_enabled_ = false;
    bool auto_start_ = false;
    bool sd_ready_ = false;
    bool info_message_active_ = false;
    unsigned long info_message_until_ = 0;
    unsigned long last_render_ms_ = 0;
    std::vector<CredentialEntry> captures_;
    unsigned long last_press_a_ = 0;
    unsigned long last_press_b_ = 0;
    unsigned long last_press_c_ = 0;
};

}  // namespace bruce::modules
